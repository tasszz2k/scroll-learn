---
alwaysApply: true
---

here’s a single, copy-paste detailed prompt to create the Chrome extension described above. It’s precise, prescriptive, and includes scope, stack, file layout, manifest, behavior, parsing rules, scheduling (SM-2), import formats, messaging APIs, UX notes, testing, and acceptance criteria. Paste it whole.

⸻

Prompt for Cursor — build “SocialStudy” Chrome extension (MV3) — TypeScript + React + Vite

Goal: build a Chrome Extension (Manifest V3) called SocialStudy that injects short quiz questions into social-media feeds (Facebook, YouTube initially) after the user scrolls N posts. Questions block/interrupt scrolling until the user answers. The app uses TypeScript + React + Vite for the dashboard and UI, MV3 service-worker background, and content-scripts for feed injection. Scheduling should use SM-2 (Anki style) for MVP. Support rich card types (MCQ single/multi, text, cloze, audio), a simple Quizlet-like import format, CSV/JSON import, and eliminate-characters normalization.

Deliver a working git repo (ZIP or GitHub) with build scripts, README, tests, and sample decks.

⸻

Tech stack & constraints
	•	Manifest V3 Chrome Extension.
	•	Frontend/dashboard: React + TypeScript + Vite.
	•	Content scripts & background: TypeScript (compiled by Vite/build). Background service worker may be plain JS in public/ for MV3 registration or built from TS (preferred: use @crxjs/vite-plugin to simplify manifest injection and SW TS build).
	•	Storage: chrome.storage.local for decks; chrome.storage.sync only for small settings (optional).
	•	No backend required for MVP (local-only). Modularize so server-sync can be added later.
	•	Browser target: Chrome (latest) — keep host permissions minimal (only specific domains).
	•	Use small, dependency-free implementations where possible (e.g., own Levenshtein implementation < 100 lines) to reduce bundle size.

⸻

High-level features (MVP)
	1.	Content script injection:
	•	Detect feed post nodes on Facebook & YouTube ([role="article"], article, and domain-specific selectors).
	•	Count visible posts and insert a quiz post after showAfterNPosts visible posts.
	•	Inserted quiz must visually resemble a native post (simple styling) and block further scrolling until answered or paused/snoozed.
	•	Quiz types supported: mcq-single, mcq-multi, text, cloze, audio (playback from mediaUrl).
	•	Configurable pause after quiz (minutes).
	•	Handle infinite scroll (MutationObserver) with debouncing.
	2.	Background service worker:
	•	Maintain canonical card storage and scheduling logic (SM-2).
	•	Expose message handlers:
	•	get_next_card_for_domain → returns next due card suitable for content script domain.
	•	card_answered (cardId, grade 0|1|2|3) → updates card scheduling and persists.
	•	import_cards_batch → accepts arrays of cards to persist (batch write with chunking).
	•	get_settings / set_settings.
	•	Precompute a short queue (e.g., next 100 due cards) for fast fetch by content-scripts.
	3.	Dashboard (React):
	•	CRUD decks & cards.
	•	Import panel supporting:
	•	Simple Quizlet-like format (one line: question|answer1|answer2...), configurable separator.
	•	CSV (columns: deck,kind,front,back,options,correct,fuzziness,mediaUrl,tags).
	•	JSON array of cards (full schema).
	•	Preview, edit, validate, and batch import.
	•	Settings:
	•	showAfterNPosts (default 5)
	•	pauseMinutesAfterQuiz (default 0)
	•	eliminateChars string (default .,!?()'")
	•	per-domain enable/disable
	•	Stats page (reviews/day, accuracy, due cards).
	•	Export (JSON) and delete deck.
	4.	Import parsing & normalization:
	•	Normalize text using NFKC, optional lowercase, strip eliminateChars, collapse whitespace.
	•	Provide preview showing normalized canonical answers.
	•	Use small Levenshtein-based fuzzy matching for text answers; thresholds configurable (defaults: exact→grade3, fuzzy>=0.95→3, 0.85–0.95→2, 0.7–0.85→1, else 0).
	5.	Scheduler (SM-2 simplified):
	•	Each card fields: id, deckId, kind, front, back, options?, correct?, canonicalAnswers?, mediaUrl?, due (ms), intervalDays, ease (float, default 2.5), repetitions, lapses, createdAt, updatedAt.
	•	Implement sm2Update(card, grade):
	•	grade 0 = Again/fail: repetitions = 0; intervalDays = 1; ease = max(1.3, ease - 0.2); lapses++.
	•	grade 1 = Hard: reduce ease slightly (e.g., -0.15) and compute interval = round(prevInterval * ease) or set to 1/3 of expected if first reps.
	•	grade 2 = Good: intervalDays = round(prevInterval * ease) (or baseline progression for first reps).
	•	grade 3 = Easy: intervalDays = round(prevInterval * ease * 1.15) and ease += 0.15.
	•	Set due = now + intervalDays * 86400 * 1000.
	•	Persist card updates in chrome.storage.local.
	6.	UX & accessibility:
	•	Inserted quiz allows keyboard interaction (1/2/3/4 keys), and is screen-reader friendly.
	•	Provide “Pause for X minutes”, “Disable on this site”, and “Skip (snooze 10 min)” controls.
	•	Avoid stealing permanent focus; modal-like insertion that blocks scrolling but can be dismissed with valid controls.

⸻

File layout (required)

socialstudy/
  package.json
  vite.config.ts
  tsconfig.json
  public/
    manifest.json
    sw.js            # or build from src/sw.ts into dist/sw.js via plugin
    icons/
  src/
    background/
      index.ts       # runtime message handlers + scheduler + storage API
      scheduler.ts   # sm2Update + helper functions
    content/
      fb.ts          # facebook-specific selectors & insert logic
      youtube.ts     # youtube-specific selectors & insert logic
      content.ts     # generic detection + observer + queue fetch + insertion
      cardRenderer.tsx # lightweight renderer for content-script (if using react in content)
    dashboard/
      main.tsx
      App.tsx
      ImportPanel.tsx
      CardEditor.tsx
      Settings.tsx
    common/
      types.ts
      storage.ts     # wrappers for chrome.storage with batching
      parser.ts      # simple format, CSV, JSON parsers + normalizeText
      fuzzy.ts       # Levenshtein / similarity function
    styles/
      dashboard.css
      content.css
    index.html       # popup or dashboard entry used as options_page
  tests/
    parser.test.ts
    scheduler.test.ts
  README.md


⸻

Manifest (example)

Place in public/manifest.json (adjust as plugin injects assets):

{
  "manifest_version": 3,
  "name": "SocialStudy",
  "version": "0.1.0",
  "description": "Learn while you scroll — quizzes injected into social feeds with spaced repetition.",
  "permissions": ["storage", "scripting", "alarms", "notifications"],
  "host_permissions": [
    "https://www.facebook.com/*",
    "https://m.facebook.com/*",
    "https://www.youtube.com/*"
  ],
  "background": {
    "service_worker": "sw.js"
  },
  "options_page": "dashboard/index.html",
  "action": {
    "default_title": "SocialStudy"
  },
  "content_scripts": [
    {
      "matches": ["https://*.facebook.com/*", "https://*.youtube.com/*"],
      "js": ["assets/content.js"],
      "run_at": "document_idle"
    }
  ],
  "icons": {"16":"icons/icon16.png","48":"icons/icon48.png","128":"icons/icon128.png"}
}


⸻

Messaging API (runtime messages)

Use chrome.runtime.sendMessage / onMessage pattern. Define message shapes:
	•	From content script → background:
	•	{ type: 'get_next_card_for_domain', domain: 'facebook.com' } → response { ok:true, card?: Card | null }
	•	{ type: 'card_answered', cardId: string, grade: 0|1|2|3 } → response { ok: true }
	•	{ type: 'batch_import', cards: Card[] } → response { ok:true, inserted: number }
	•	{ type: 'get_settings' } → { settings }
	•	{ type: 'set_settings', settings } → { ok:true }
	•	Background event handling:
	•	Use chrome.alarms to recalc due queue periodically (every hour) and when cards are added.

Implement proper sendResponse and return true in listeners when async.

⸻

Import format specifics
	1.	Simple Quizlet-like:
	•	One card per line.
	•	Separator configurable (default |).
	•	Optional deck prefix: [deck:deck-name]Question|Answer1|Answer2
	•	Eliminate-chars: configurable string of characters removed during normalization.
	•	Normalize: NFKC → lowercase (optional) → strip eliminate chars → collapse whitespace.
	2.	CSV:
	•	Header deck,kind,front,back,options,correct,fuzziness,mediaUrl,tags.
	•	options pipe-separated or JSON array string.
	•	correct pipe-separated option ids or text canonical answers.
	3.	JSON:
	•	Array of objects matching Card schema.

Provide preview and validation UI before import. Batch writes in chunks (e.g., 100 cards per write) to chrome.storage.local.

⸻

Card matching rules (map to grade 0..3)
	•	MCQ single:
	•	exact correct → grade 3
	•	wrong → grade 0
	•	MCQ multi:
	•	compute fraction correct; map to grades: ≥0.9→3, 0.6–0.9→2, 0.2–0.6→1, <0.2→0
	•	Text:
	•	exact normalized match → 3
	•	regex match (if acceptedRegex provided) → 3
	•	fuzzy Levenshtein similarity:
	•	≥0.95 → 3
	•	0.85–0.95 → 2
	•	0.7–0.85 → 1
	•	else → 0
	•	Cloze:
	•	apply text matching per blank and average results → map to grade.

⸻

Developer acceptance criteria / tests
	1.	Build completes: npm install + npm run build produces dist/ and manifest assets ready to Load unpacked.
	2.	Content script:
	•	inserts a quiz after configured showAfterNPosts on sample Facebook feed (use test HTML or sandbox).
	•	content script fetches a card via get_next_card_for_domain.
	•	answering triggers card_answered and background updates due appropriately.
	3.	Import:
	•	Import simple format text and CSV in dashboard → preview → persisted to storage → reflected in background queue.
	4.	Scheduler:
	•	sm2Update unit tests: show expected interval/ease changes for a few grades.
	5.	UI:
	•	Dashboard shows imported cards and settings work (change showAfterNPosts, eliminateChars and effect is visible).
	6.	Accessibility:
	•	Inserted quiz is keyboard operable and includes ARIA labels.

Include unit tests:
	•	parser.test.ts for normalizeText & parseSimpleLine.
	•	scheduler.test.ts for sm2Update logic.

⸻

Deliverables
	•	Complete repo with documented README: how to run, how to load extension, developer notes.
	•	npm scripts: dev, build, preview, test.
	•	Sample deck(s) in samples/ (including a few language cards).
	•	Minimal CSS so injected quiz looks native but clearly branded.
	•	Tests and short guide for how to extend to more sites.

⸻

Small UX details to implement
	•	When a quiz is inserted, freeze scroll only for the viewport region containing it (avoid global overflow:hidden unless necessary). If global freeze is needed, include a visible “Pause/Skip” button.
	•	Provide a toolbar on injected post with three actions: Pause X minutes, Disable on this site, Report layout issue.
	•	Provide per-domain selectors in settings to adjust detection heuristics.
	•	Keep insertion idempotent (don’t insert duplicate quiz nodes).

⸻

Extra (nice-to-have if time permits)
	•	Use @crxjs/vite-plugin to manage manifest and SW TS compilation.
	•	Auto-reload extension during development (plugin).
	•	Optionally support typed answers with fuzzy keyboard hints and show confidence percent.
	•	Export / import .apkg (Anki) as a later enhancement (mention as TODO).

⸻

Final note for Cursor
	•	Prioritize robustness: domain-specific selectors + generic fallback with MutationObserver.
	•	Keep background as single source of truth for scheduling.
	•	Keep content scripts lightweight (fetch card + render + send grade).
	•	Write clean, commented TypeScript and include unit tests for parser + scheduler.